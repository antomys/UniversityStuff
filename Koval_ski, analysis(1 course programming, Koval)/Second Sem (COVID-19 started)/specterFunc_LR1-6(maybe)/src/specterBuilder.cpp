/*
 * functionItself.cpp
 *
 *  Created on: Jan 29, 2020
 *      Author: vlad
 */



#include <iostream>
#include <string>
#include <cmath>
#include <fstream>
#include <sstream>

#include "specterBuilder.hpp"
using namespace std;


Specter::Specter(int length,int maxF, int axes, int* specterArray)
{
	(*this).length = length;
	(*this).maxF = maxF;
	(*this).axes = axes;
	(*this).specter = specterArray;
	(*this).totalElements = pow (maxF, axes);
}

Specter::Specter (const Specter& oldSpecter)
{
	counter = 0;
	length = oldSpecter.axes;
	maxF = oldSpecter.maxF;
	axes = oldSpecter.axes;
	totalElements = oldSpecter.totalElements;
	int* array = new int [totalElements];
	specter = array;
	int tmp = 0;
	int *ptr = oldSpecter.specter;
	for (int i = 0; i < totalElements; i++)
	{
		tmp = *(ptr+i);
		*(specter+i) = tmp;
	}
}


int Specter::buildSpecter(Function& function) // pointer to the executed generator function

/*
 * Function fills the array with a specter of numbers,
 * generated by a function, that Function object points to.
 * Amount of numbers generated is changed (LCM (length, maxF))
 * so that there will be enough coordinates.
 * Possible problems:
 * 1) Function generates a number that is >maxF
 * 	  (fixed by assigning a value to a variable with % maxF)
 * 2) Wrong parameters passed to function (axes or maxF) - can't be fixed in C++
 */
{
	int newLength = LCM (length, axes);
	int currentCoordinate = 0;
	int pointerIndex;
	int i = 0;
	while (i < newLength)
	{
		pointerIndex = 0;
		for (int j = 0; j < axes; ++j)
		{
			currentCoordinate = function.next() % maxF;
			++i;
			pointerIndex += currentCoordinate;
			if (j != axes-1) pointerIndex *= maxF;
		}
		(*(specter+pointerIndex))++;
	}

	int nonZeroElementCounter = 0;
	for (int i = 0; i < totalElements; i++)
	{
		if (*(specter+i) != 0)
		{
			++nonZeroElementCounter;
		}

	}
	return nonZeroElementCounter;
};

int Specter::GCD (int a, int b)
{
	int max = (a >= b) ? a : b;
	int min = (a >= b) ? b : a;
	while (min > 0)
	{
		max = max % min;
		int tmp = max;
		max = min;
		min = tmp;
	}
	return max;
}

int Specter::LCM (int a, int b)
{
	return (int)(((long long)a*b) / GCD(a, b));
}


// Converts specter to string.
string Specter::specter2String ()
{
	counter = 0;
	string html = "";
	html += "<style>"
      "table{"
      "padding: 10px;"
      "border: 1px solid black;"
      "border-collapse: collapse;"
	  "background-color:#c75e5e;"
      "}"
	 "table td {border:solid 5px red;"
            "border-top-color:#FEB9B9;"
            "border-right-color:#B22222;"
            "border-bottom-color:#B22222;"
            "border-left-color:#FEB9B9;} </style>";

	html += "<html> \n";
	html += "<body> \n";

	html += buildTable(axes, 0);

	html += "</body> \n";
	html += "</html> \n";
	return html;
}

// Writes out HTML to cout.
int Specter::specter2cout ()
{
	cout << specter2String ();
	return counter;
}


// Writes out HTML to file (given the filename)
int Specter::specter2File (string fileName) // the name of the file where the output is written
{
	ofstream fout (fileName);
	fout << specter2String ();
	fout.close();
	return counter;
}

/* Helper recursive function to build the structure of HTML file.
 * Depth of recursion = amount of axes.
 * (each new axis = new nested table)
 */

string Specter::buildTable(int depth  // depth of recursion
					   	 , int index) /* incomplete index from the previous recursion call
									   * (see if-condition to understand how it is used)
									  */
{
	string tableHTML = "";
	tableHTML +="<table> \n";
	for (int i = 0; i < maxF; i++)
	{
		tableHTML +="<tr> \n";
		tableHTML +="<td> \n";

		if (depth > 1)
		{
			tableHTML += buildTable (depth-1, (index*maxF)+i);
		}
		else
		{
			int tmp = *(specter+i);
			counter++;
			stringstream ss;
			ss << tmp;
			string str = ss.str();
			tableHTML += str;

		}
		tableHTML += "</td> \n";
		tableHTML +="</tr> \n";
	}
	tableHTML +="</table> \n";
	return tableHTML;
}


Specter::operator string() const
{
	string result = "Resulting specter: \n";
	for (int i = 0; i < totalElements; i++)
	{
		result += to_string(*(specter+i)) + " ";
	}
	return result;
}


bool Specter::operator == (Specter& that)
{
	bool result  = compareSpecters(*this, that);
}

bool Specter::compareSpecters (Specter& sp1, Specter& sp2)
{
	if (sp1.totalElements != sp2.totalElements)
		return false;

	int thisTotalSum = 0;
	int thatTotalSum = 0;
	for (int i = 0; i < totalElements; i++)
	{
		thisTotalSum += *(sp1.specter+i);
		thatTotalSum += *(sp2.specter+i);
	}
	int thisGCD = thisTotalSum;
	int thatGCD = thatTotalSum;
	//cout << thisTotalSum << ' ' << thatTotalSum << endl;
	for (int i = 0; i < totalElements; i++)
	{
		thisGCD = GCD(thisGCD, (*(sp1.specter+i) > 0 ? *(sp1.specter+i) : thisGCD));
		thatGCD = GCD(thatGCD, (*(sp2.specter+i) > 0 ? *(sp2.specter+i) : thatGCD));
	}
	// cout << "Print GCDs: "<<thisGCD << ' ' << thatGCD << endl;
	for (int i = 0; i < totalElements; i++)
	{
		int tmp1 = *(sp1.specter+i);
		int tmp2 = *(sp2.specter+i);
		*(sp1.specter+i) = tmp1 / thisGCD;
		*(sp2.specter+i) =  tmp2 / thatGCD;
	}



	for (int i = 0; i < totalElements; i++)
	{
		//cout << *(sp1.specter+i)<< ' ' << *(sp2.specter+i) << endl;
		if (*(sp1.specter+i) != *(sp2.specter+i))
			return false;
	}
	return true;
}
